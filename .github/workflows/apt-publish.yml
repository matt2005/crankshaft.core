# Project: Crankshaft
# This file is part of Crankshaft project.
# Copyright (C) 2025 OpenCarDev Team
#
#  Crankshaft is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  Crankshaft is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with Crankshaft. If not, see <http://www.gnu.org/licenses/>.

name: APT Publish (Reusable)

on:
  workflow_call:
    inputs:
      build-run-id:
        description: 'GitHub Actions run ID containing build artifacts'
        required: true
        type: string
      channel:
        description: 'APT channel (nightly|stable)'
        required: true
        type: string
      architectures:
        description: 'Space-separated architectures to publish (amd64 arm64 armhf)'
        required: false
        default: 'amd64 arm64 armhf'
        type: string
      create-release:
        description: 'Create GitHub release after publishing'
        required: false
        default: false
        type: boolean

env:
  APT_REPO_URL: ${{ secrets.APT_REPO_URL || 'https://packages.opencardev.org' }}
  APT_SSH_HOST: ${{ secrets.APT_SSH_HOST }}
  APT_SSH_USER: ${{ secrets.APT_SSH_USER }}
  APT_SSH_KEY: ${{ secrets.APT_SSH_KEY }}
  APT_SIGNING_KEY_ID: ${{ secrets.APT_SIGNING_KEY_ID }}

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      deb-artifacts: ${{ steps.artifacts.outputs.debs }}
      publish-start: ${{ steps.timing.outputs.start }}
    steps:
      - name: Record publish start time
        id: timing
        run: echo "start=$(date -u +%s)" >> $GITHUB_OUTPUT

      - name: List available artifacts
        id: artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const run_id = '${{ inputs.build-run-id }}';
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: run_id
            });
            
            const debs = artifacts.data.artifacts
              .filter(a => a.name.includes('deb'))
              .map(a => a.name)
              .join(',');
            
            core.setOutput('debs', debs);

  validate:
    name: Validate Packages
    needs: prepare
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download DEB artifacts
        uses: actions/download-artifact@v4
        with:
          path: deb-artifacts
          github-token: ${{ github.token }}

      - name: Install validation tools
        run: |
          sudo apt-get update
          sudo apt-get install -y lintian apt-utils

      - name: Validate packages
        run: |
          .github/scripts/package/validate-deb.sh ./deb-artifacts --json | tee validation-report.json

      - name: Check validation results
        run: |
          INVALID=$(jq '.invalid_packages' validation-report.json)
          if [ "$INVALID" -gt 0 ]; then
            echo "::error::Package validation failed - $INVALID invalid packages"
            exit 1
          fi

      - name: Upload validation report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: apt-validation-report
          path: validation-report.json
          retention-days: 30

  prepare-release:
    name: Prepare Release Metadata
    needs: prepare
    runs-on: ubuntu-latest
    outputs:
      release-info: ${{ steps.release.outputs.info }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate release metadata
        id: release
        run: |
          CHANNEL='${{ inputs.channel }}'
          BUILD_RUN='${{ inputs.build-run-id }}'
          PUBLISH_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          # Create release info JSON
          RELEASE_INFO=$(cat << EOF
          {
            "channel": "$CHANNEL",
            "build_run_id": "$BUILD_RUN",
            "publish_time": "$PUBLISH_TIME",
            "architectures": "${{ inputs.architectures }}",
            "git_sha": "${{ github.sha }}",
            "git_ref": "${{ github.ref_name }}"
          }
          EOF
          )
          
          echo "info=$RELEASE_INFO" >> $GITHUB_OUTPUT

  publish:
    name: Publish to APT Repository
    needs: [prepare, validate, prepare-release]
    runs-on: ubuntu-latest
    # Use concurrency to ensure only one publish at a time per channel
    concurrency:
      group: apt-publish-${{ inputs.channel }}
      cancel-in-progress: false
    environment:
      name: apt-${{ inputs.channel }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all DEB artifacts
        uses: actions/download-artifact@v4
        with:
          path: deb-packages
          github-token: ${{ github.token }}

      - name: Setup SSH key
        if: env.APT_SSH_KEY != ''
        run: |
          mkdir -p ~/.ssh
          echo "${{ env.APT_SSH_KEY }}" | base64 -d > ~/.ssh/apt_deploy_key
          chmod 600 ~/.ssh/apt_deploy_key
          ssh-keyscan -H "${{ env.APT_SSH_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Prepare staging directory
        run: |
          mkdir -p staging/${{ inputs.channel }}
          
          # Copy all DEB files
          find deb-packages -name "*.deb" -exec cp {} staging/${{ inputs.channel }}/ \;
          
          # Verify we have packages
          DEB_COUNT=$(ls staging/${{ inputs.channel }}/*.deb 2>/dev/null | wc -l)
          if [ $DEB_COUNT -eq 0 ]; then
            echo "::error::No DEB files found in artifacts"
            exit 1
          fi
          
          echo "Found $DEB_COUNT DEB packages to publish"

      - name: Sign Release file
        if: env.APT_SIGNING_KEY_ID != ''
        env:
          GPG_KEY_DATA: ${{ secrets.APT_GPG_KEY }}
          GPG_PASSPHRASE: ${{ secrets.APT_GPG_PASSPHRASE }}
        run: |
          # Setup GPG
          export GNUPGHOME=$(mktemp -d)
          trap "rm -rf $GNUPGHOME" EXIT
          
          # Import key
          if [ -n "${{ env.GPG_KEY_DATA }}" ]; then
            echo "${{ env.GPG_KEY_DATA }}" | base64 -d | gpg --import --batch --no-tty
          fi
          
          # Create Release file
          cat > staging/${{ inputs.channel }}/Release << EOF
          Archive: Debian
          Origin: OpenCarDev
          Label: Crankshaft
          Suite: trixie
          Codename: trixie
          Version: 12.0
          Date: $(date -u +"%a, %d %b %Y %H:%M:%S %z")
          Architectures: amd64 arm64 armhf
          Components: main
          Description: Crankshaft automotive infotainment system
          Channel: ${{ inputs.channel }}
          EOF
          
          # Generate Packages metadata
          cd staging/${{ inputs.channel }}
          apt-ftparchive packages . > Packages 2>/dev/null || true
          gzip -c Packages > Packages.gz || true
          
          # Sign Release
          gpg --default-key "${{ env.APT_SIGNING_KEY_ID }}" \
              --armor --detach-sign \
              -o Release.gpg Release
          
          cd - > /dev/null

      - name: Upload to APT server
        if: env.APT_SSH_HOST != ''
        run: |
          # Create staging area on server
          STAGING_PATH="/var/lib/apt/staging-${{ inputs.channel }}-$(date +%s)"
          
          ssh -i ~/.ssh/apt_deploy_key \
              "${{ env.APT_SSH_USER }}@${{ env.APT_SSH_HOST }}" \
              "mkdir -p $STAGING_PATH"
          
          # Upload packages
          rsync -avz -e "ssh -i ~/.ssh/apt_deploy_key" \
                staging/${{ inputs.channel }}/* \
                "${{ env.APT_SSH_USER }}@${{ env.APT_SSH_HOST }}:$STAGING_PATH/"
          
          if [ $? -ne 0 ]; then
            echo "::error::Failed to upload packages"
            exit 1
          fi

      - name: Promote staging to production (atomic)
        if: env.APT_SSH_HOST != ''
        run: |
          # Use symlink swap for atomic promotion
          STAGING_PATH="/var/lib/apt/staging-${{ inputs.channel }}-$(date +%s)"
          PROD_PATH="/var/lib/apt/production/${{ inputs.channel }}"
          
          ssh -i ~/.ssh/apt_deploy_key \
              "${{ env.APT_SSH_USER }}@${{ env.APT_SSH_HOST }}" \
              "bash -c 'set -e; \
               mkdir -p \"$PROD_PATH\"; \
               if [ -L \"$PROD_PATH/apt.current\" ]; then \
                   rm \"$PROD_PATH/apt.current\"; \
               fi; \
               ln -s apt.new \"$PROD_PATH/apt.current\"; \
               [ -L \"$PROD_PATH/apt.current\" ] && echo \"Promotion successful\"'"

      - name: Publish results
        if: always()
        run: |
          cat > publish-result.json << EOF
          {
            "channel": "${{ inputs.channel }}",
            "status": "${{ job.status }}",
            "build_run_id": "${{ inputs.build-run-id }}",
            "publish_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "architectures": "${{ inputs.architectures }}"
          }
          EOF
          cat publish-result.json

      - name: Upload publish report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: apt-publish-report
          path: publish-result.json
          retention-days: 90

  cleanup:
    name: Cleanup
    needs: publish
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Clean build artifacts
        uses: geekyeggo/delete-artifact@v2
        with:
          name: 'crankshaft-*'
