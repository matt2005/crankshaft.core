# Implementation Plan: Slim AndroidAuto UI

**Branch**: `001-slim-aa-ui` | **Date**: 2026-01-10 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/001-slim-aa-ui/spec.md`

**Note**: This plan was generated by the `/speckit.plan` command following the research and design phases.

## Summary

Create a lightweight, standalone AndroidAuto-focused UI application that provides immediate AndroidAuto projection and minimal settings (brightness, volume, connection preferences). **The slim UI leverages the existing Crankshaft core library** (AndroidAutoService, PreferencesService, EventBus, AudioRouter) rather than reimplementing services. The application must run efficiently on Raspberry Pi 4 with both EGLFS (physical display) and VNC (remote access) support, achieve 30% lower memory footprint than the main Crankshaft UI. Technical approach: Qt6 QML frontend with thin C++ facade classes that bridge QML to existing core services. Core handles AndroidAuto (via AASDK), settings persistence (SQLite), logging, and audio routing.

## Technical Context

**Language/Version**: C++17, QML (Qt6)  
**Primary Dependencies**: Crankshaft Core library (AndroidAutoService, PreferencesService, EventBus, Logger, AudioRouter), Qt6 (Base 6.5+, QML, Quick, Multimedia, SQL)  
**Storage**: SQLite via core's PreferencesService (managed by core)  
**Testing**: Qt Test framework (QTest), integration tests on Raspberry Pi 4  
**Target Platform**: Raspberry Pi 4 (32-bit and 64-bit), Raspberry Pi OS (Bookworm+), EGLFS and VNC display backends  
**Project Type**: Desktop application (Qt6 QML frontend + core library)  
**Performance Goals**: <150MB memory during active AndroidAuto projection, <100ms touch input latency, <3s connection time, <500ms settings panel open time  
**Constraints**: Must support EGLFS and VNC without code changes, must work on Raspberry Pi 4 hardware, must use existing core services, separate DEB package required  
**Scale/Scope**: 2 main screens (AndroidAuto projection + Settings), ~500-800 LOC C++ (facade classes only), ~500 LOC QML, minimal complexity - **core handles business logic**

## Constitution Check

**Status**: ✅ PASS (with observations)

### Compliance Assessment

**I. Code Quality & Maintainability**: ✅ COMPLIANT
- Plan includes Google C++ Style Guide adherence
- QML best practices documented in research.md
- Clear separation: C++ backend, QML frontend
- File headers will include standard project headers
- Static analysis: clang-format, clang-tidy, cppcheck in CI

**II. Test-First & Testing Standards**: ✅ COMPLIANT
- Unit tests required for SettingsManager, AAConnectionManager
- Integration tests for connection flows, settings persistence
- Coverage target: >80% for core modules
- Qt Test framework provides deterministic testing
- CI gates: all tests must pass before merge

**III. UX Consistency & Accessibility**: ✅ COMPLIANT
- Qt Quick Controls 2 for consistent UI components
- Light and dark theme support (FR-017)
- i18n ready (default en-GB)
- On-screen button (44pt minimum touch target) for settings
- Responsive layout adapts to any resolution (FR-023)
- "Design for Driving" compliant: minimal distraction, large tap areas

**IV. Performance & Resource Constraints**: ✅ COMPLIANT
- Memory budget: <150MB during projection (30% reduction vs full UI)
- Touch latency: <100ms target (FR-005, SC-005)
- Connection time: <5s target (SC-001)
- Performance tests in CI for memory usage and input latency
- Optimization for Raspberry Pi 4 documented in research.md

**V. Observability, Versioning & Change Management**: ✅ COMPLIANT
- Structured JSON logging for all components
- Connection state changes logged with timestamps (FR-016, FR-022)
- Settings corruption logged with recovery event (FR-010)
- Semantic versioning for package releases
- DEB package with proper version management

### Re-evaluation After Phase 1 Design

**Data Model Review**: ✅ PASS
- All entities have clear validation rules
- State machines defined for connection lifecycle
- Relationships between entities documented

**Contracts Review**: ✅ PASS
- Clean separation between C++ services and QML UI
- All interfaces use Q_PROPERTY, Q_INVOKABLE patterns
- Signals for async event notification
- Thread safety considerations documented

**No Constitution Violations** - Proceeding to implementation.

## Project Structure

### Documentation (this feature)

```text
specs/001-slim-aa-ui/
├── spec.md                        # Feature specification
├── plan.md                        # This implementation plan
├── research.md                    # Phase 0: Technology research and decisions
├── data-model.md                  # Phase 1: Entity definitions and relationships
├── quickstart.md                  # Phase 1: User/developer guide
├── contracts/                     # Phase 1: Internal API specifications
│   ├── README.md
│   ├── settings_manager_contract.md
│   ├── aa_connection_manager_contract.md
│   ├── audio_handler_contract.md      # (to be created in Phase 2)
│   └── video_frame_provider_contract.md # (to be created in Phase 2)
├── checklists/
│   └── requirements.md            # Specification quality checklist
└── tasks.md                       # Phase 2 output (created by /speckit.tasks - NOT YET CREATED)
```

### Source Code (repository root)

```text
crankshaft-mvp/
├── CMakeLists.txt                 # Root CMake (add ui-slim subdirectory)
├── core/                          # EXISTING: Core library (reused by slim UI)
│   ├── services/
│   │   ├── android_auto/          # AndroidAutoService (AASDK wrapper)
│   │   ├── preferences/           # PreferencesService (SQLite settings)
│   │   ├── eventbus/              # EventBus (pub/sub messaging)
│   │   ├── logging/               # Logger (structured logging)
│   │   ├── audio/                 # AudioRouter (audio management)
│   │   └── service_manager/       # ServiceManager (lifecycle)
│   └── hal/                       # Hardware abstraction layer
├── ui-slim/                       # NEW: Slim UI component (QML frontend ONLY)
│   ├── CMakeLists.txt             # Links against crankshaft-core library
│   ├── main.cpp                   # Application entry, initializes core services
│   ├── src/                       # C++ facade classes (thin wrappers)
│   │   ├── AndroidAutoFacade.h    # QML bridge to AndroidAutoService
│   │   ├── AndroidAutoFacade.cpp  # Exposes core service to QML
│   │   ├── PreferencesFacade.h    # QML bridge to PreferencesService
│   │   └── PreferencesFacade.cpp  # Exposes preferences to QML
│   ├── qml/                       # QML UI components
│   │   ├── main.qml               # Application root
│   │   ├── AAProjectionView.qml   # AndroidAuto projection surface
│   │   ├── SettingsPanel.qml      # Settings interface
│   │   ├── DeviceSelectionDialog.qml  # Multi-device selection
│   │   ├── ConnectionStatusView.qml   # Connection state indicator
│   │   └── components/            # Reusable UI components
│   │       ├── SettingsSlider.qml
│   │       └── ThemeToggle.qml
│   ├── resources/                 # Assets
│   │   ├── icons/                 # UI icons
│   │   └── qml.qrc                # Qt resource file
│   ├── translations/              # Internationalization
│   │   └── slim-ui_en_GB.ts       # English (GB) translation file
│   └── tests/                     # Unit and integration tests
│       ├── test_aa_facade.cpp     # Test QML bridge
│       ├── test_preferences_facade.cpp
│       └── integration/
│           └── test_connection_flow.cpp
├── packaging/                     # Existing packaging directory
│   └── slim-ui/                   # NEW: Slim UI package config
│       ├── control                # DEB package metadata (depends on crankshaft-core)
│       └── crankshaft-slim-ui.service  # Systemd service file
└── scripts/                       # Existing build scripts (reused)
```

**Structure Decision**: Qt6 QML frontend with core library integration. The slim UI is organized as a lightweight component (`ui-slim/`) that:
- **Reuses all core services** - no duplicate AndroidAuto, settings, logging, or audio code
- Provides only QML UI + thin C++ facade classes to bridge QML ↔ core services
- Satisfies FR-001 (isolated from main UI) while maximizing code reuse
- Links against `libcrankshaft-core.so` library
- Separate packaging with core library dependency (satisfies FR-021)

**Key Architectural Decision**: The slim UI does NOT reimplement AndroidAuto integration, settings management, or audio routing. It wraps existing core services with QML-friendly facades (Q_PROPERTY, Q_INVOKABLE). This dramatically reduces code size, eliminates duplication, and ensures consistency with the main Crankshaft UI.

## Complexity Tracking

**Status**: No Constitution violations requiring justification.

This feature maintains appropriate complexity:
- Single application architecture (not adding unnecessary projects)
- Direct AASDK library usage (no abstraction layers needed)
- Simple JSON file persistence (no database required)
- Minimal UI surface area (2 screens only)
- Straightforward Qt/QML patterns (no custom frameworks)

The architecture is as simple as possible while meeting all requirements.
